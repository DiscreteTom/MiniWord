# 迭代器使用说明 大炮版

在内部结构Data中使用迭代器

## 获取迭代器

在知道迭代器位置时建议使用下列函数获取迭代器**而不是构造函数**

	//in class Data
	iterator begin();
	iterator iteratorAt(int parentNodeIndex, int indexInNode);
	iterator iteratorAt(int parentNodeIndex, int parentHeapIndex, int indexInHeap);

因为这些函数**有**溢出判断 如果溢出会返回一个溢出迭代器

而构造函数**没有**溢出判断

## private member

	Node * m_parentNode;//指向迭代器的父Node
	Heap * m_parentHeap;//指向迭代器的父Heap
	int m_index;//当前迭代器在父Heap中的下标(0~99)
	bool overflow;//是否溢出

## 构造函数

### iterator()

默认构造函数 默认构造一个溢出迭代器

- m_parentNode = NULL
- m_parentHeap = NULL
- m_index = -1
- overflow = true

### iterator(Node * parentNode, Heap * parentHeap, int index)

构造函数外的唯一构造函数 重审此构造函数**没有溢出判断 默认无溢出**

- m_parentNode = parentNode
- m_parentHeap = parentHeap
- m_index = index
- overflow = false

## 方法

	bool isOverFlow() const;//判断是否溢出
	void clear();//将overflow设置为flase
	Node * parentNode() const ;//获取父Node
	Heap * parentHeap() const ;//获取父Heap
	int index() const ;//获取m_index

	//以下函数参考 迭代器使用说明-大佬版
	QChar operator*() const ;
	const iterator & operator++();
	const iterator & operator++(int);
	const iterator & operator--();
	const iterator & operator--(int);
	const iterator & operator+(int n) const ;
	const iterator & operator-(int n) const ;
	bool operator==(const iterator & another) const ;
	int operator-(const iterator & another) const ;//return width unit
	const iterator & operator=(const iterator & another);
	operator bool ();//convert to bool

## 溢出相关

何时会溢出

1. 调用默认构造函数 返回溢出迭代器
2. 进行算术运算超出Data数据范围 返回溢出迭代器
3. 调用iteratorAt函数超出Data数据范围 返回溢出迭代器
4. 被溢出迭代器赋值 获取溢出迭代器的溢出状态

两个迭代器判断相等时(operator==)只要有一个迭代器溢出则不相等

## 需要注意的

注意迭代器的内部结构是两个指针和一个索引

所以当内部数据被修改时原本未溢出的迭代器可能变成溢出的迭代器

这是迭代器本身**检测不到**的

这时迭代器就会变成一个**失效迭代器**

大佬在外部使用时不会出现这个问题

但是你在修改内部数据时会遇到

所以建议操作链表时**尽量减少迭代器使用**

应当使用双向链表的原生操作

仅仅把迭代器作为一个**定位的工具**