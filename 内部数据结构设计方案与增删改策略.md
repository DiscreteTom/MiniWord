# 内部数据结构设计方案与增删改策略

## 内部数据结构概述

内部数据结构由一个被声明为**Q_OBJECT**的C++类**Data**组成

Data类中包含了如下嵌套类

| 类名 | 访问控制 | 介绍 |
| --- | --- | ---|
| Heap | private | 内含100个字符，是内部数据结构申请内存的最小单位。若干个Heap在Node中组成双向链表 |
| Node | private | 用来表示数据中的一个段落。每个Node内含一个Heap双向链表。若干个Node在Data中组成双向链表 |
| Action | private | 用来描述撤销或重做操作 |
| ActionStack | private | 用来存放撤销操作和重做操作的栈。有最大容量。 |
| iterator | public | 迭代器，用来线性访问内部数据中的字符 |

主程序可通过如下接口访问内部数据结构或执行操作

```c++
	//=========== about iterator ===========
	iterator begin();//获取指向第一个字符的迭代器
	iterator end();//获取指向最后一个字符的迭代器（注意：和一般迭代器不同，这里的end()返回的不是超尾元素而是尾元素
	iterator iteratorAt(int parentNodeIndex, int indexInNode);//获取指向指定段落指定字符的迭代器
	iterator iteratorAt(int parentNodeIndex, int parentHeapIndex, int indexInHeap);//获取指向指定段落指定堆指定字符的迭代器

	//========== about text edit ========
	iterator add(const iterator & locate, const QString & str, ActionStack::UndoType undo = ActionStack::UndoType::NORMAL);//在指定位置增加字符或字符串
	iterator del(const iterator & startLocate, const iterator & endLocate, bool hind = false, ActionStack::UndoType undo = ActionStack::UndoType::NORMAL);//删除指定位置的字符或字符串
	iterator edit(const iterator & startLocate, const iterator & endLocate, const QString & str);//把指定位置的字符串替换为另一个指定字符串
	iterator find(const iterator & startLocate, const QString & str);//从某个起始位置开始查找某个字符串
	iterator cut(const iterator & startLocate, const iterator & endLocate);//剪切某一位置的字符串到系统剪贴板
	iterator copy(const iterator & startLocate, const iterator & endLocate);//复制某一位置的字符串到系统剪贴板
	iterator paste(const Data::iterator & startLocate, const Data::iterator &endLocate);//在指定位置粘贴系统剪贴板中的字符串
	iterator undo(const iterator & now);//撤销操作
	iterator redo(const iterator & now);//重做操作
	void clear();//清空整个数据结构
	bool isEmpty();//判断内部数据是否为空
	QString text(const iterator & startLocate, const iterator & endLocate);//返回数据结构中指定位置的字符串

	//=========== about undoStack & redoStack ============
	bool undoStackEmpty() const {return undoStack.length() == 0;}//判断撤销栈是否为空
	bool redoStackEmpty() const {return redoStack.length() == 0;}//判断重做栈是否为空
	void resetStackSize(int n);//设置撤销栈和重做栈的最大深度
	void clearStack();//清空撤销栈和重做栈

	//========= about file ===========
	void save(const QString & pathAndName);//把数据结构中的数据保存到指定文件
	void read(const QString & pathAndName);//从指定文件中读取数据到内部数据结构
```

## 数据相关(Heap & Node)

### 堆(Heap)概述

- Data类的私有嵌套类，不可被主程序访问
- 每个堆的容量为100个字符(QChar)
- 是内部数据结构扩容的单位
- 数据结构为双向链表

### Heap内数据

```c++
QChar ch[100];//100个字符的空间
int charNum;//堆内实际字符数量
Heap * preHeap;//指向上一个堆的指针，双向链表的组成结构
Heap * nextHeap;//指向下一个堆的指针，双向链表的组成结构
Node * parentNode;//指向父Node的指针
```

由于Heap是Data的私有嵌套类，无法被外部访问，所以为了方便将所有数据和方法的访问控制为public

堆内字符向低索引靠拢，用charNum控制访问

### Heap相关方法及实现策略

Heap类包含以下public方法

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| Heap(Node * parent); | Heap构造函数。以parent为父Node指针新建一个堆。不建议直接使用此函数增加Heap，建议使用addHeap函数 |
| void moveToNextHeap(int start); | 把本Heap中从起始位置(start)开始（包括start）到最后一个字符移动到父Node内的下一个Heap中。如果下一个Heap不存在或无法容纳则创建一个新的Heap并移动 |
| void moveToNewNode(int start); | 把从本Heap的起始位置(start)开始（包括起始位置）到父Node的最后一个字符的字符串移动到一个新的Node中，新的Node接在本Heap的父Node后 |
| iterator add(const QString & str, int index); | 在本Heap的指定位置(index)插入指定字符串(str)，如果Heap无法容纳则在此Heap后添加新的Heap。此函数无法处理换行符。返回增加字符串后光标的位置 |
| iterator begin(); | 返回指向此Heap第一个字符的迭代器 |
| void del(int index); | 删除此Heap第index个字符。只能删除一个字符。无法处理换行符。无法处理删除后可能出现的空Heap。这些交给Data::del处理 |
| QChar operator[](int n) const ; | 根据下标n返回此Heap中第n个字符。调用heap[n]相当于调用了heap.ch[n]。安全性不如heap.ch[n]。只能在n合法时返回正确字符 |
| QChar & operator[](int n); | 和上面函数类似。返回指定字符的引用。无法用来增加或删除字符（因为增加或删除字符需要修改charNum），可以用来替换字符 |

Data中包含以下private方法以管理Heap

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| Heap \* addHeap(Heap \* heapp); | 通过调用Heap构造函数在指定Heap(heapp)后添加一个Heap。此函数拥有链接前后Heap的功能，建议添加Heap时调用此函数而不是Heap的构造函数。返回指向新Heap的指针 |
| void delHeap(Heap * heapp); | 删除指定Heap(heapp)。此函数可以在删除Heap后链接前后Heap，也可以在当前Node中不含Heap时通过调用delNode删除Node。建议在删除Heap时调用此函数而不是直接delete |
| void mergeNextHeap(Heap * heapp); | 试图合并当前Heap(heapp)和当前Heap的下一个Heap。如果下一个Heap不存在或当前Heap无法容纳两个Heap中的总字符量则不合并 |

### 段落(Node)概述

- Data类的私有嵌套类，不可被主程序访问
- 每个Node内包含一个Heap链表
- 表示Data中的一个段落，最后一个字符必为换行符
- 数据结构为双向链表

### Node内数据

```c++
Node * preNode;//指向前一个Node，双向链表的组成部分
Node * nextNode;//指向下一个Node，双向链表的组成部分
Heap * firstHeap;//指向内部Heap链表的第一个Heap
Data * parent;//指向父Data
```

和Heap一样，Node是Data的私有嵌套类，无法被外部访问，所以为了方便将所有数据和方法的访问控制为public

### Node相关方法及实现策略

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| Node(Data \* m_parent, Heap \* source = NULL); | 构造函数。以m_parent为父Data新建一个Node。如果source不为空，则窃取source和其后同一Node内的Heap作为此Node的Heap链表。此函数无法在新建Node后链接前后Node。建议使用addNode函数添加Node而不是此函数 |
| ~Node(); | 析构函数。仅删除此Node下的所有Heap，不会链接前后Node。建议使用delNode删除Node而不是直接使用delete删除Node |
| int heapNum(); | 返回此Node中的Heap数 |
| int charNum(); | 返回此Node中所有字符总数 |
| Heap * lastHeap(); | 返回此Node最后一个Heap的指针 |
| iterator begin(); | 获取指向此Node第一个字符的迭代器 |
| Heap & operator[](int n); | 获取此Node内指定下标的Heap的引用 |

Data中包含以下private方法以管理Node

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| Node * addNode(Node * nodep, Heap * source = NULL); | 通过调用Node的构造函数在指定Node(nodep)后根据source添加一个新的Node。此函数可以链接前后Node，建议使用此函数添加Node而不是使用Node构造函数。返回新Node的指针 |
| void delNode(Node * nodep); | 删除指定Node(nodep)，此函数可以链接前后Node，并且会判断此Node是否为Data中的唯一Node。建议使用此函数删除Node而不是直接delete |
| void mergeNextNode(Node * nodep); | 尝试合并当前Node(nodep)和下一个Node。如果下一个Node不存在则不合并。合并时会自动删除掉当前Node的换行符。此函数应该在删除换行符时被调用 |
| Node & operator[](int n); | 根据下标返回指定Node的引用 |

## 操作相关(Action & ActionStack)

### Action & ActionStack概述

撤销和重做通过**撤销重做栈**实现。撤销重做栈是ActionStack。栈内元素为Action.

### Action类的实现策略

和Heap/Node一样，Action为Data私有成员，为了方便将所有成员设为public

Action类声明了以下public枚举常量用来表明当前Action的种类（增加或删除）

```c++
enum Type{ADD, DEL};
```

Action类包含以下public成员变量

```c++
int nodeIndex;//此操作在第几个Node进行的
int heapIndex;//此操作在第几个Heap进行的
int indexInHeap;//此操作在当前Heap的什么位置进行的
Type m_type;//此操作是增加操作还是删除操作
QString m_str;//此操作改变的字符串
```

由于更改过程涉及到Node或Heap的删除，所以定位Action时不像迭代器那样使用指针而是使用下标索引来定位

Action类的方法只有一个，即构造函数

```c++
Action(int locateNode = -1, int locateHeap = -1, int index = -1, Type type = ADD, QString str = "")
	:nodeIndex(locateNode), heapIndex(locateHeap), indexInHeap(index), m_type(type), m_str(str) {}
```

可以把Action视为一个struct

### ActionStack类的实现策略

ActionStack类是**拥有最大容量的栈**，所以不能使用容器Stack。此处使用了Qt中的容器QVector来存储Action。

ActionStack拥有以下私有成员变量

```c++
QVector<Action> actions;//Action容器
int maxDepth;//最大深度，即最大撤销重做次数
```

ActionStack类拥有以下public方法

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| ActionStack(int depth = 20); | 构造函数，生成一个空栈。默认最大深度20 |
| void push(Action action); | 栈的push操作 |
| Action pop(); | 栈的pop操作 |
| void pop(Action & receiver); | 通过参数返回值的pop |
| void clear(); | 清空栈 |
| int length() const ; | 返回当前栈内元素数量 |
| void setMaxDepth(int n); | 设置栈深为n。如果n非正整数则赋值n为20。此函数会自动调用clear()清空栈 |

ActionStack还提供了如下public枚举常量用来给Data类的接口定义撤销类型

```c++
enum UndoType {NORMAL, UNDO, REDO};
```

在Data中含有一些接口以供主程序控制撤销重做栈。详见下文*接口函数与相关实现策略*

## 迭代器相关(iterator)

### 迭代器概述

为了提高主程序访问内部数据结构的效率，我们设计了迭代器来避免每次从数据头部检索数据

迭代器和指针一样，但实现了跨Node和跨Heap移动。主要用来使主程序逐字符访问内部数据、作为接口函数的参数与返回值以定位光标、跨Heap实现查找时的KMP算法

### 迭代器内部数据

迭代器是Data中的public嵌套类。为了避免主程序访问数据，所有数据被设计为private

以下是迭代器的private变量

```c++
Node * m_parentNode;//迭代器指向的字符的父Node指针
Heap * m_parentHeap;//迭代器指向的字符的父Heap指针
int m_index;//迭代器指向的字符在父Heap中的索引位置
bool overflow;//是否溢出
```

迭代器使用指针和索引定位字符以实现随机访问。如果迭代器在移动时移动到了可用字符外则被视为溢出

### 迭代器的public方法

迭代器的一切方法都是public的

下面是迭代器的方法与实现策略

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| iterator(); | 默认构造函数，返回一个**溢出迭代器**。用来生成异常。如果不是出于返回异常的目的，永远不要使用默认构造函数 |
| iterator(Node * parentNode, Heap * parentHeap, int index) | 构造函数，根据参数值定位一个迭代器。因为Node和Heap是Data的私有嵌套类所以此函数无法被外部主函数使用。此构造函数**没有溢出检测**，得到的迭代器一定是非溢出的（即使它不指向字符）。使用时要小心 |
| int parentNodeIndex() const ; | 为撤销重做栈设计的函数。返回迭代器父Node在Data中的索引 |
| int parentHeapIndex() const ; | 为撤销重做栈设计的函数。返回迭代器父Heap在Data中的索引 |
| bool isOverFlow() const ; | getter函数，返回溢出状态 |
| Node * parentNode() const ; | getter函数，返回父Node |
| Heap * parentHeap() const ; | getter函数，返回父Heap |
| int index() const ; | getter函数，返回迭代器在父Heap中的索引 |
| void clear(); | 清除一个迭代器的溢出状态。不建议使用 |
| QChar operator*() const ; | 获取迭代器指向的字符 |
| iterator operator++(); | 迭代器向后移动一个字符。可以跨Node和跨Heap移动。如果当前迭代器已经溢出则不移动。如果迭代器移动后溢出则撤销移动并将迭代器置为溢出状态。此时如果配合clear()函数可以获得移动前的非溢出迭代器 |
| iterator operator++(int); | 后置++运算符 |
| iterator operator--(); | 迭代器向前移动一个字符。可以跨Node和跨Heap移动。如果当前迭代器已经溢出则不移动。如果迭代器移动后溢出则撤销移动并将迭代器置为溢出状态。此时如果配合clear()函数可以获得移动前的非溢出迭代器 |
| iterator operator--(int); | 后置--运算符 |
| iterator operator+(int n) const ; | 向前移动n个字符。有溢出检测 |
| iterator operator-(int n) const ; | 向后移动n个字符。有溢出检测 |
| bool operator==(const iterator & another) const ; | 判断两个迭代器是否相等，忽略溢出状态，只根据位置判断 |
| bool operator!=(const iterator & another) const ; | 判断两个迭代器是否不相等。策略和operator==相同 |
| int operator-(const iterator & another) const ; | 判断两个迭代器之间的字符数量。如果参数迭代器在此迭代器之后则返回一个正数。如果参数迭代器在此迭代器之前则返回-1，如果两个迭代器相等则返回0 |
| iterator operator=(const iterator & another); | 赋值，包括溢出状态 |
| operator bool() const ;| 直接把迭代器转换为bool值。反映了迭代器是否*非溢出*，即迭代器是否是好的迭代器 |

### 迭代器使用相关事项

对Data外部的主程序来说，迭代器只能够根据位置访问字符，不能够用来修改内部数据。修改内部数据要使用下文提到的接口函数。

外部主程序**永远不要**通过构造函数获得迭代器，因为默认构造函数只能得到溢出迭代器，非默认构造函数的参数都是Data私有嵌套类而无法被外部使用。主程序应通过后文接口函数中的迭代器相关函数来获得迭代器。

对内部数据来说，迭代器保存的数据是指针。在修改内部数据时很可能把指针指向的内容篡改而得到野指针。所以内部函数的编写应尽量减少迭代器的使用，应仅使用数据结构相关内容。仅仅把迭代器当做和外部主函数的接口。

## Data类私有成员与实现策略

### Data类的private变量

Data作为整个内部数据结构的宏观类，包含以下私有成员变量

```c++
Node * firstNode;//Node链表的第一个Node的指针
int stackDepth;//撤销重做栈的深度
ActionStack undoStack;//撤销栈
ActionStack redoStack;//重做栈
```

### Data类的private方法

除了nodeNum()方法，其他方法都已在上文中描述过

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| int nodeNum() const ; | 获得Node链表长度 |
| Heap \* addHeap(Heap \* heapp); | 通过调用Heap构造函数在指定Heap(heapp)后添加一个Heap。此函数拥有链接前后Heap的功能，建议添加Heap时调用此函数而不是Heap的构造函数。返回指向新Heap的指针 |
| void delHeap(Heap * heapp); | 删除指定Heap(heapp)。此函数可以在删除Heap后链接前后Heap，也可以在当前Node中不含Heap时通过调用delNode删除Node。建议在删除Heap时调用此函数而不是直接delete |
| void mergeNextHeap(Heap * heapp); | 试图合并当前Heap(heapp)和当前Heap的下一个Heap。如果下一个Heap不存在或当前Heap无法容纳两个Heap中的总字符量则不合并 |
| Node * addNode(Node * nodep, Heap * source = NULL); | 通过调用Node的构造函数在指定Node(nodep)后根据source添加一个新的Node。此函数可以链接前后Node，建议使用此函数添加Node而不是使用Node构造函数。返回新Node的指针 |
| void delNode(Node * nodep); | 删除指定Node(nodep)，此函数可以链接前后Node，并且会判断此Node是否为Data中的唯一Node。建议使用此函数删除Node而不是直接delete |
| void mergeNextNode(Node * nodep); | 尝试合并当前Node(nodep)和下一个Node。如果下一个Node不存在则不合并。合并时会自动删除掉当前Node的换行符。此函数应该在删除换行符时被调用 |
| Node & operator[](int n); | 根据下标返回指定Node的引用 |

### Data的其他设计

显示界面光标显示的是当前指向字符的左侧。为了保证光标可以移动到最后一个字符之后，所有Node的最后一个字符必须是换行符，这样光标指向此换行符时光标的显示位置就是实际最后一个字符的左侧。

按照这个设计，所谓的"空Node"指的是只含一个换行符的Node，Data在构造时必须有一个Node，这个Node只有一个换行符。

## 接口函数与相关实现策略

### 构造函数与析构函数

有且只有一个构造函数

```c++
explicit Data(QObject *parent = 0);
```

构造函数设置了默认撤销重做栈的深度为20，并使用Node的构造函数赋值给firstNode

```c++
//! can only be used in MainWindow
Data::Data(QObject *parent) : QObject(parent)
{
	firstNode = new Node(this);
	stackDepth = 20;
}
```

析构函数负责删除所有Node。因为不需要链接前后Node，所以使用delete而不是delNode是更快速的选择

```c++
Data::~Data()
{
	//delete all node
	auto p = firstNode;
	while (p){
		auto q = p;
		p = p->nextNode;
		delete q;
	}
}
```

### 迭代器相关

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| iterator begin(); | 获得指向整个内部数据第一个字符的迭代器 |
| iterator end(); | 获得指向整个内部数据最后一个字符的迭代器（注意不是指向超尾元素的） |
| iterator iteratorAt(int parentNodeIndex, int indexInNode); | 获得指定段落指定位置的迭代器 |
| iterator iteratorAt(int parentNodeIndex, int parentHeapIndex, int indexInHeap); | 获得指定段落指定Heap指定位置的迭代器 |

### 文本编辑相关

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| iterator add(const iterator & locate, const QString & str, ActionStack::UndoType undo = ActionStack::UndoType::NORMAL); | 在指定位置(locate)处添加字符串(str)。如果字符串为空串则直接返回locate。如果字符串为单个字符且为换行符，调用moveToNewNode函数将指定位置后面的字符移动到新的段落。如果字符串为单个字符且不为换行符，调用Heap::add函数把这个字符交给Heap处理。如果字符串长度大于1，调用string类的split函数将字符串根据换行符分裂为多个字符串，将每个不含换行符的字符串交给Heap::add处理，把换行符调用moveToNewNode处理。最后根据undo的状态对撤销重做栈进行压栈或弹栈 |
| iterator del(const iterator & startLocate, const iterator & endLocate, bool hind = false, ActionStack::UndoType undo = ActionStack::UndoType::NORMAL); | 删除指定位置（从startLocate到endLocate）的字符串。如果startLocate等于endLocate，只删除单个字符，根据hind判断删除前一个字符（用户按下backspace）还是当前字符（用户按下delete），如果删除的是换行符则直接调用mergeNextNode函数，否则调用Heap::del删除单个字符。如果startLocate不等于endLocate，即删除一个长度大于1的字符串，先判断startLocate和endLocate的位置关系，得到靠前的迭代器frontLocate和靠后的迭代器hindLocate，把hindLocate后面的字符通过moveToNextHeap移动到下一个Heap，删除frontLocate和hindLocate间的所有Heap和Node，因为hindLocate指向的字符已经移动到了下一个Heap中，所以也要删掉hindLocate所在的Heap，最后合并即可。最后的最后根据undo的状态对撤销重做栈进行压栈或弹栈 |
| iterator edit(const iterator & startLocate, const iterator & endLocate, const QString & str); | 先调用del删除字符串，再在删除后的位置调用add添加字符串 |
| iterator find(const iterator & startLocate, const QString & str); | 使用KMP算法从指定位置开始查找指定字符串 |
| iterator cut(const iterator & startLocate, const iterator & endLocate); | 把指定区域的字符串删除并置于系统剪贴板 |
| iterator copy(const iterator & startLocate, const iterator & endLocate); | 把指定区域的字符串置于系统剪贴板 |
| iterator paste(const Data::iterator & startLocate, const Data::iterator &endLocate) ; | 把系统剪贴板的字符串add到指定位置 |
| iterator undo(const iterator & now); | 撤销。如果撤销栈为空，返回now |
| iterator redo(const iterator & now); | 重做。如果重做栈为空，返回now |
| void clear(); | 清空Node和撤销重做栈内数据 |
| bool isEmpty(); | 判断Data是否为空。如果Data只有一个Node且这个Node只有一个换行符则判定为空 |
| QString text(const iterator & startLocate, const iterator & endLocate); | 获得从startLocate到endLocate的字符串。startLocate与endLocate的位置关系在内部会进一步确定 |

### 撤销重做栈相关

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| bool undoStackEmpty() const ; | 判断撤销栈是否为空 |
| bool redoStackEmpty() const ; | 判断重做栈是否为空 |
| void resetStackSize(int n); | 重新设置撤销重做栈的深度，会清空两个栈 |
| void clearStack(); | 清空两个栈 |

### 文件相关

| 函数头 | 函数功能与实现策略 |
| --- | --- |
| void save(const QString & pathAndName); | 把Data中的文本保存在外部文件中。会自动去掉Data末尾的设计上添加的换行符
| void read(const QString & pathAndName); | 清空当前数据和撤销重做栈后读取指定文件中的数据。会自动在文末加上换行符 |

### 信号(Qt)

```c++
void WindowUdate();//迭代器移动需要刷新窗口时发送此信号
void dataChanged();//数据发生改变需要保存时发送此信号
```
