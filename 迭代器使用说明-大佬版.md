# 迭代器使用说明-大佬版

## 前提假设

假设在interface里面拥有Data类型的成员data

## 迭代器的操作

首先 把迭代器想象成一个指向QChar的指针

假设已经存在迭代器i和j以及整型数字n 则可以使用如下操作

	QChar operator*() const ;//获得迭代器指向的QChar
	const iterator & operator++();//迭代器自加 即右移1
	const iterator & operator++(int);//迭代器自加 即右移1
	const iterator & operator--();//迭代器自减 即左移1
	const iterator & operator--(int);//迭代器自减 即左移1
	const iterator & operator+(int n) const ;//迭代器右移n
	const iterator & operator-(int n) const ;//迭代器左移n
	bool operator==(const iterator & another) const ;//判断两个迭代器是否指向同一个位置(而不是指向的字符是否相同)
	int operator-(const iterator & another) const ;//返回两个迭代器间的字符宽度单位 如果减数迭代器在被减数迭代器之前则返回一个负数
	bool isOverFlow() const ;//返回迭代器是否溢出
	void clear();//迭代器溢出状态还原
	operator bool();//返回迭代器是否overflow

	void move(int unitWidthCount, int windowUnitCount);//根据窗口宽度和字符宽度单位数量移动迭代器


还需要知道

- 迭代器一切左移右移操作都可以跨Heap和Node移动
- 如果迭代器在最后一位字符右移或第一位字符左移则视为溢出(overflow)
- 两个迭代器判断相等时(operator==)只要有一个迭代器溢出则不相等

迭代器可以自动转换成bool型变量表示其是否**未**溢出

也就是迭代器是否可用(good)

所以可以像下面这样这样使用迭代器

	auto t = data.begin();
	while(t){
		//do something
	}

### 减号运算符获取两个迭代器之间的字符宽度单位

假设存在迭代器Data::iterator t1, t2;

可以使用t1 - t2计算两个迭代器之间的字符宽度单位

结果为以下三种情况之一

- 正整数 代表从t1到t2之间字符宽度单位总量
- -1 代表t1在t2后面 需要计算t2 - t1
- -2 计算时遇到换行符

第三种情况说明此运算符**无法跨段落计算字符宽度单位总数**

## 获得迭代器

**!!不要使用构造函数获得迭代器!!**

	data.begin();

可以获得一个迭代器指向data内的第一个字符 如果不存在第一个字符则视为溢出(overflow)

	data.iteratorAt(i, j);

获得指向第i段第j位字符的迭代器 i和j从0开始计数

	data.iteratorAt(i, j, k);

获得指向第i个Node第j个Heap第k个字符的迭代器 i,j,k从0开始计数

## 关于interface的设计

以下设计仅供参考 变量名字为了方便理解写的特别长请勿参考

interface应该至少包含以下设计

	class interface{
		class m_cursor{//光标
			iterator locate;//光标指向的字符在Data中的位置
			int x, y;//以像素为单位 相对于窗口左上角的显示坐标
		};

		m_cursor current_cursor;//当前光标
		m_cursor another_cursor;//另一个的光标
		iterator first_char_in_window;//指向窗口内的第一个字符的字符串
	};

## 利用迭代器实现增删改查

Data包含以下函数

	//增删改查
	iteraotr add(const iterator & locate, const QString & str);
	iteraotr del(const iterator & startLocate, const iterator & endLocate, bool hind = 0);
	iteraotr edit(const iterator & startLocate, const iterator & endLocate, const QString & str);
	iterator find(const iterator & startLocate, const QString & str);
	//剪切复制粘贴
	iterator cut(const iterator & startLocate, const iterator & endLocate);
	iterator copy(const iterator & startLocate, const iterator & endLocate);
	iterator paste(const iterator & locate);//get string from system clipboard

所以根据上一节的设计可以如下实现增删改查

	data.add(current_cursor.locate, str);//返回结束后的迭代器位置
	data.del(previous_cursor.locate, current_cursor.locate);//函数内部会自动判断两个迭代器的前后关系 不需要interface判断 返回结束后endLocate的位置
	data.edit(previous_cursor.locate, current_cursor.locate, str);//函数内部会自动判断两个迭代器的前后关系 不需要interface判断 返回结束后endLocate的位置
	current_cursor.locate = find(current_cursor.locate, str);//查找第一个匹配的位置并返回给current_cursor 如果找不到则返回原current_cursor

实现剪切复制粘贴

	data.cut(previous_cursor.locate, current_cursor.locate);
	data.copy(previous_cursor.locate, current_cursor.locate);
	data.paste(current_cursot.locate);